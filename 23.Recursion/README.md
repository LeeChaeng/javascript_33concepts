# Recursion

- 23th concept of 33

## 재귀(Recursion)이 뭘까?

재귀를 간단하게 정의하면 한 함수가 자기 자신을 호출하는 순간이다.

재귀가 무엇인지 더 자세히 알아보자. 일단은 가장 유명한 재귀 예제를 한 번 살펴보자.

이 예제는 제공된 정수의 팩토리얼을 반환한다.

```js
function factorial(x) {
  if (x < 0) return;
  if (x === 0) return 1;
  return x * factorial(x - 1);
}

factorial(3);
// 6
```

- 중요한 부분은 4번째 라인에서 일어난다.
- `return X * factorial(x-1);` 이다.
- 함수가 자기 자신을 다시 호출하고 있다.
- 하지만, 처음에 호출했던 값보다 1작아진 파라미터와 함께 다시 호출된다.
- 4번째 라인과 같은 구문이 이 함수를 재귀함수로 만들어준다.

> 이 코드를 알기 전 팩토리얼의 개념을 이해해야한다.

- 어떤 수의 팩토리얼을 구하기 위해서 우리는 어떤 숫자의 -1을 구하여 1이 될 때까지 곱해야 한다.

## 재귀의 3가지 중요한 특성

모든 재귀 함수는 3가지의 중요한 특성을 갖는다.

### 종료 조건

- 간단하게, `if(나쁜 값이 들어왔다면) {정지!};`와 같이 이해하면 된다.
- 종료 조건은 재귀의 안전장치이다. 이를 긴급 브레이크처럼 생각하자.
- 좋지 않은 입력 값이 들어왔을 때, 재귀가 계속하여 동작하는 것을 방지해준다.
- 팩토리얼 예제에서는 `if(x<0) return;` 이 우리가 설정한 종료 조건이다.
- 음수의 팩토리얼을 구하는 것은 불가능하기 때문에, 음수 입력 값이 들어왔을 때, 팩토리얼 함수가 작동하지 않길 원한다.

### 기반 조건(Base case, 기저 상태)

- 간단하게, `if(이런 일이 일어난다면) {성공!}`와 같이 이해하면 된다.
- 이 조건 역시 재귀 함수를 멈춘다는 점을 감안하면, 기반 조건은 어쩌면 재귀의 종료 조건과 비슷하다.
- 하지만 종료 조건은 모든 나쁜 데이터들을 잡아낸다.
- **_반면에 기반 조건은 재귀 함수의 목적이다._**
- 기반 조건은 주로 `if`문 내부에 있다.
- 팩토리얼 예제에서는 `if (x === 0) return 1`이 기반 조건이다.

### 재귀

- 간단하게, 함수가 자기 자신을 호출하는 것이다.
- 팩토리얼 예제에서 `return x * factorial(x-1);` 부분이 실제로 재귀가 일어나는 곳이다.
- 우리는 숫자 `x`가 `factorial(x-1)` 함수의 결과 값으로 곱해진 어떤 값을 반환한다.

### 위의 3가지를 동시에 보자

여전히 팩토리얼 예제가 어떻게 동작하는지 정확히 모를 수도 있다. 아래 예제가 도움을 줄 것이다.

```js
function factorial(x) {
  // 종료 조건
  if (x < 0) return;

  // 기반 조건
  if (x === 0) return 1;

  // 재귀
  return x * factorial(x - 1);
}

factorial(3);
// 6
```

## 팩토리얼 함수 흐름

우리가 팩토리얼 함수를 호출했을 때 정확히 어떤 일들이 벌어지는지 다시 한 번 체크해보자

1. 우리는 숫자 3을 넘겨서 함수를 호출한다.

```js
factorial(3);
```

2. 함수가 동작하게 된다. if문을 넘어가고 재귀 부분을 실행한다. 정수 3과 factorial(3-1)이 곱해진 결과를 반환한다.

```js
return 3 * factorial(2);
```

3. factorial(2)가 동작할때, if를 다시 넘어가고 재귀가 일어난다. 정수 2와 factorial(2-1)이 곱해진 결과를 반환한다.

```js
return 2 * factorial(1);
```

4. factorial(1)이 동작할때, if문이 또 한 번 넘어가게 되고 재귀가 일어난다. 정수 1과 factorial(1-1)이 곱해진 결과를 반환한다.

```js
return 1 * factorial(0);
```

5. factorial(0)이 동작할 때, 뭔가 다른 일이 일어난다. 0은 우리의 기반 조건이다. 그래서 if문에 걸려 함수는 1을 반환한다.

```js
if (x === 0) return 1;
```

이제 함수가 리턴을 마쳤다. 재귀는 단순히 중첩된 호출이다. 모든 중첩된 함수에서는 가장 내부에 중첩된 함수가 가장 먼저 반환된다.

`factorial(0)` 는 `1`
`factorial(1)` 는 `1 * factorial(0)`, 또는 `1*1`
`factorial(2)` 는 `2 * factorial(1)`, 또는 `2*1*1`
`factorial(3)` 는 `3 * factorial(2)`, 또는 `3*2*1*1`

```js
return 1 * 1 * 2 * 3;
```

같은 구조로 되어있는 다른 예제이다.

```js

factorial(3) returns 3 * factorial(2)
factorial(2) returns 2 * factorial(1)
factorial(1) returns 1 * factorial(0)
factorial(0) returns 1
// 여기서 기반 조건이 충족됩니다. 재귀 함수는 안에서 부터 바깥으로 값을 반환해나갑니다.
factorial(0) returns 1                 => 1
factorial(1) returns 1 * factorial(0)  => 1 * 1
factorial(2) returns 2 * factorial(1)  => 2 * 1 * 1
factorial(3) returns 3 * factorial(2)  => 3 * 2 * 1 * 1
// 3 * 2 * 1 * 1 = 6
```

## 두 번째 예제를 보자

이는 완전히 다른 방향으로 갈 것이다. 이 예제 또한 인터넷에서 유명한 예제이다.
문자열을 거꾸로 뒤집는 것과 관련된 예제이다.

> 앞으로 구현할 방법이 자바스크립트에서 문자열을 뒤집기 위해 가장 효율적인 방법은 아님을 알아두자. 훨씬 빠른 방법들이 많다. 그냥 흔한 재귀 예제일 뿐이다.

코드는 다음과 같이 생겼다.

```js
function revStr(str) {
  if (str === "") return "";
  return revStr(str.substr(1)) + str[0];
}

revStr("cat");
// tac
```

위의 코드 예제를 보고 알수 있는 몇가지가 있다.

1. `str === ""`는 우리의 기반 조건(base case)이다. 문자열 내부에 아무런 글자도 남아있지 않을 때, 우리는 목적을 달성한 것이다.
2. `return rev(str.substr(1)) + str[0];`가 재귀가 일어나는 코드 라인이다.
3. 종료 조건은 없다. 왜냐면 이 예제에서는 기반 조건이 곧 종료 조건이기 때문이다. 문자열은 음수와 같은 특성을 가질 수 없다. 그래서 함수에 문자열이 들어오는 한 괜찮다.

### 한줄 한줄 쪼개보자

이 예제에서 우리는 `cat`이라는 문자열을 뒤집는다. 시작 부분에서 `cat`이라는 문자열을 넘기며 함수를 호출한다.

```js
revStr("cat");
```

재귀 함수가 동작한다.

자바스크립트에서, `substr()` 메소드는 특정한 위치에서 시작하는 문자열을 반환한다. `cat.substr(1) === 'at'`와 같은 결과를 내보낸다.

`str[0]`는 문자열에서 첫 인덱스에 위치한 문자를 내보낸다. `cat[0] === 'c'`와 같은 결과를 내보낸다.

```js
return revStr(str.substr(1)) + str[0];

// 아래와 같습니다.
return revStr("at") + "c";
```

재귀가 다시 한 번 동작한다.

```js
return revStr(str.substr(1)) + str[0];

// 아래와 같습니다.
return revStr("t") + "a";
```

재귀가 마지막으로 동작한다.

```js
return revStr(str.substr(1)) + str[0];

//아래와 같습니다.
return revStr("") + "t";
```

이번엔 기반 조건이 동작하고, 함수가 빈 문자열을 반환한다.

```js
if (str === "") return "";
```

이제 함수가 결과를 반환한다. 모든 것이 풀렸고 순서대로 반환한다.

```js
return "" + "t" + "a" + "c";
```

### 더 잘게 쪼개보자

추가로, 여기서 차례차례 다시 진행해보자

```js
revStr('cat')  returns revStr('at') + 'c'
revStr('at')   returns revStr('t') +  'a'
revStr('t')    returns revStr('') +   't'
revStr('')     returns               ''
```

이제, 여기 중첩된 함수 호출들이 있다. 중첩된 함수 호출을 갖고 있을 때, 가장 안쪽 함수가 가장 먼저 실행된다. 계속 리턴을 하며, 쌓인 재귀를 풀어나가기 시작하는 과정이다.

```js
revStr('')     returns                ''  => ''
revStr('t')    returns revStr('') +   't' => '' + 't'
revStr('at')   returns revStr('t') +  'a' => '' + 't' + 'a'
revStr('cat')  returns revStr('at') + 'c' => '' + 't' + 'a' + 'c'
// tac
```
